{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"JJSONV","tagline":"Java JSON Validator using YAML-like shemas.","google":"UA-31675056-2","body":"Java JSON Validator\r\n- Requires Jackson ASL 1.9.7 Core & Mapper\r\n\r\nSchemas\r\n-------\r\nIt simply speaks for itself, how amazingly easy to use!\r\n\r\nObject content is detected by _tabs_, do not use more tabs than you should use.\r\n```\r\nmodel:object\r\n\tname:string\r\n\tpublic:boolean\r\n\tmembers:object[]\r\n\t\tname:string\r\n\t\tsize:int\r\npages:object[]\r\n\tdesign:string\r\n```\r\n_note_: You can nest arrays as deep as you want!\r\nValidating\r\n==========\r\n```java\r\nSchemaFactory factory = new SchemaFactory();\r\nObjectMapper mapper = new ObjectMapper();\r\nSchema schema = factory.create(new File(\"schema.jsons\"));\r\ntry {\r\n\tschema.validate(mapper.readTree(new File(\"data.json\")));\r\n} catch(ValidationException e) {\r\n\t// Invalid JSON!\r\n}\r\n```\r\nTracing\r\n-------\r\nYou can see where validation errors happen, this is incredibly useful when sending it back to a JavaScript web application.\r\n```java\r\nSchemaFactory factory = new SchemaFactory();\r\nObjectMapper mapper = new ObjectMapper();\r\nSchema schema = factory.create(new File(\"schema.jsons\"));\r\ntry {\r\n\tschema.validate(mapper.readTree(new File(\"false-data.json\")));\r\n} catch(ValidationException e) {\r\n\t// Will print something like \"object.members[0][1].inner[4].size\"\r\n\t// Depends on what you're validating of course.\r\n\tSystem.out.println(e);\r\n\t// You can use e.getElements() for even deeper inspection\r\n}\r\n```\r\nCustom Element Validators\r\n=========================\r\nA SchemaFactory has the following standard validators preregistered;\r\n```java\r\npublic SchemaFactory() {\r\n\tvalidators = new HashMap<String, Class<? extends Validator>>();\r\n\tvalidators.put(\"string\", StringValidator.class);\r\n\tvalidators.put(\"bool\", BooleanValidator.class);\r\n\tvalidators.put(\"boolean\", BooleanValidator.class);\r\n\tvalidators.put(\"int\", IntValidator.class);\r\n\tvalidators.put(\"integer\", IntValidator.class);\r\n\tvalidators.put(\"object\", PlainObjectValidator.class);\r\n}\r\n```\r\nYou can register your own custom validators at a SchemaFactory, the SchemaFactory\r\nwill then create instances of these validators when they are used in a schema file.\r\nHere's a simple example of a validator that accepts JSON values that are integers or strings\r\n```java\r\npublic class IntOrStringValidator extends ElementValidator {\r\n\r\n\t@Override\r\n\tpublic boolean ok(JsonNode node, ValidationContext context) {\r\n\t\treturn node.isInt() || node.isTextual();\r\n\t}\r\n\r\n}\r\n```\r\nAnd this is how you can regiser it!\r\n```java\r\nSchemaFactory factory = new SchemaFactory();\r\nfactory.add(\"thing\", IntOrStringValidator.class);\r\n```\r\nEasy right? You should extend either ```com.pseudocoding.jjsonv.validators.ElementValidator``` or ```com.pseudocoding.jjsonv.validators.ObjectValidator```\r\nValidation Context\r\n==================\r\nValidationContext is data that is passed to every Validator, the Validators can read from it\r\nand add more data to it - It's very useful for expensive loads such as a custom \"UserValidator\", so that after\r\nchecking if your User objects exists in the database, and obtaining a reference to it; You can then store that\r\nalready loaded data into the ValidationContext. The ValidationContext is returned\r\nby ```Schema.validate(JsonNode)```, you can then read all your data from the ValidationContext.\r\n\r\nHere's an example of a validator that only accepts existing \"members\" -- See also: test/tests/TestValidator.java\r\n( This validator will create a map to store data it's data in - note that it doesn't check \r\nwether or not the \"member\" was already loaded into the ValidationContext )\r\n```java\r\npublic class TestValidator extends ElementValidator {\r\n\r\n\tprivate final Map<String, String> existingMembers;\r\n\r\n\tpublic TestValidator() {\r\n\t\texistingMembers = new HashMap<String, String>();\r\n\t\texistingMembers.put(\"Member1\", \"Data1\");\r\n\t\texistingMembers.put(\"Member2\", \"Data2\");\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean ok(JsonNode node, ValidationContext context) {\r\n\t\t// Check for valid data\r\n\t\tif (node.isTextual() == false)\r\n\t\t\treturn false;\r\n\t\t// Load up our existing member\r\n\t\tString key = node.getTextValue();\r\n\t\tString value = existingMembers.get(key);\r\n\t\tif (value == null)\r\n\t\t\treturn false;\r\n\t\t// Get or create our map\r\n\t\t@SuppressWarnings(\"unchecked\")\r\n\t\tMap<String, String> members = (Map<String, String>) context\r\n\t\t\t\t.get(\"Members\");\r\n\t\tif (members == null)\r\n\t\t\tmembers = new HashMap<String, String>();\r\n\t\t// Add our member which we know exists\r\n\t\tmembers.put(key, value);\r\n\t\t// Store our members again\r\n\t\tcontext.put(\"Members\", members);\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n```\r\nExample on how to use the ValidationContext -- See also: test/tests/Tests.java\r\n```java\r\n// Load custom schema\r\nSchema schema = factory.create(basicCustomSchema);\r\n// Get the result of validation\r\nValidationContext context = schema.validate(mapper.readTree(basicJson));\r\n@SuppressWarnings(\"unchecked\")\r\nMap<String, String> members = (Map<String, String>) context.get(\"Members\");\r\nfor(Map.Entry<String, String> entry : members.entrySet()){\r\n\t// Do something with loaded data\r\n}\r\n```"}